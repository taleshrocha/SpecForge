"""Requirements API controller for handling requirement-related endpoints."""

from typing import List, Optional
from fastapi import APIRouter, HTTPException, status, Query
from pydantic import BaseModel
import logging

from backend.requirements.dtos.requirement_dto import RequirementDTO
from backend.requirements.models.requirement import Requirement
from backend.requirements.services.requirements_service import RequirementsService
from backend.requirements.models.wiegers_matrix import WiegersMatrix
from backend.requirements.services.wiegers_service import WiegersService
from backend.requirements.models.glossary import Glossary
from backend.requirements.services.glossary_service import GlossaryService

# Set up logging
logger = logging.getLogger(__name__)

router = APIRouter(prefix="/requirement", tags=["requirement"])

class WiegersAnalysisRequest(BaseModel):
    """Request model for Wiegers matrix analysis."""
    requirement_ids: List[str]

@router.post("", response_model=Requirement)
async def create_requirement(requirement: RequirementDTO):
    """Create a new requirement.
    
    Args:
        requirement: The requirement data to create.
        
    Returns:
        The created requirement.
    """
    service = RequirementsService()
    try:
        created_requirement = await service.create_requirement(requirement)
        return created_requirement
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create requirement: {str(e)}")

@router.post("/ai-description", response_model=Requirement)
async def create_requirement_with_ai_description(requirement: RequirementDTO):
    """Create a new requirement with AI-generated description.
    
    Args:
        requirement: The requirement data to create (description will be generated by AI).
        
    Returns:
        The created requirement with AI-generated description.
    """
    service = RequirementsService()
    try:
        created_requirement = await service.create_requirement_with_ai_description(requirement)
        return created_requirement
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to create requirement with AI description: {str(e)}")

@router.get("", response_model=List[Requirement])
async def get_requirements(stakeholder: Optional[str] = Query(None, description="Nome da parte interessada para ordenação por prioridade")):
    """Get all requirements.
    
    Args:
        stakeholder: Optional stakeholder name to sort requirements by priority
    
    Returns:
        List of all requirements, optionally sorted by stakeholder priority.
    """
    logger.info(f"GET /requirement endpoint called with stakeholder: {stakeholder}")
    service = RequirementsService()
    try:
        requirements = await service.get_all_requirements(stakeholder_name=stakeholder)
        logger.info(f"Returning {len(requirements)} requirements")
        return requirements
    except Exception as e:
        logger.error(f"Failed to retrieve requirements: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve requirements: {str(e)}")

@router.post("/glossary", response_model=Glossary)
async def generate_and_save_glossary():
    """Generate a new glossary from all requirements and save it to database.
    
    Removes any existing glossary and creates a new one.
    
    Returns:
        The created glossary with terms and definitions.
    """
    logger.info("POST /requirement/glossary endpoint called")
    service = GlossaryService()
    try:
        glossary = await service.generate_and_save_glossary()
        logger.info(f"Generated and saved glossary with {len(glossary.terms)} terms")
        return glossary
    except Exception as e:
        logger.error(f"Failed to generate and save glossary: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to generate and save glossary: {str(e)}")

@router.get("/glossary", response_model=Glossary)
async def get_current_glossary():
    """Get the current glossary from database.
    
    Returns:
        The current glossary with terms and definitions.
        
    Raises:
        HTTPException: When no glossary is found.
    """
    logger.info("GET /requirement/glossary endpoint called")
    service = GlossaryService()
    try:
        glossary = await service.get_current_glossary()
        if glossary is None:
            raise HTTPException(status_code=404, detail="No glossary found. Generate one first using POST /requirement/glossary")
        logger.info(f"Retrieved glossary with {len(glossary.terms)} terms")
        return glossary
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to retrieve glossary: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve glossary: {str(e)}")

@router.get("/{requirement_id}", response_model=Requirement)
async def get_requirement(requirement_id: str):
    """Get a specific requirement by ID.
    
    Args:
        requirement_id: The unique identifier for the requirement.
        
    Returns:
        The requirement data.
        
    Raises:
        HTTPException: When requirement ID is invalid or requirement not found.
    """
    service = RequirementsService()
    try:
        requirement = await service.get_requirement_by_id(requirement_id)
        if requirement is None:
            raise HTTPException(status_code=404, detail="Requirement not found")
        return requirement
    except HTTPException:
        # Re-raise HTTPExceptions (like our 404) without wrapping them
        raise
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to retrieve requirement: {str(e)}")

@router.post("/wiegers/analyze", response_model=List[WiegersMatrix])
async def analyze_requirements(request: WiegersAnalysisRequest):
    """Generate Wiegers matrix analysis for requirements using AI.
    
    Args:
        request: Request containing list of requirement IDs
        
    Returns:
        List of created WiegersMatrix objects ordered by priority
        
    Raises:
        HTTPException: When analysis fails
    """
    wiegers_service = WiegersService()
    try:
        matrices = await wiegers_service.generate_and_save_matrices(request.requirement_ids)
        return matrices
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )

@router.get("/wiegers", response_model=List[WiegersMatrix])
async def get_all_matrices():
    """Get all Wiegers matrices ordered by priority.
    
    Returns:
        List of WiegersMatrix objects
    """
    wiegers_service = WiegersService()
    try:
        return await wiegers_service.get_all()
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erro ao buscar matrizes Wiegers: {str(e)}"
        )

@router.get("/wiegers/{requirement_id}", response_model=WiegersMatrix)
async def get_matrix_by_requirement(requirement_id: str):
    """Get Wiegers matrix by requirement ID.
    
    Args:
        requirement_id: The requirement ID
        
    Returns:
        WiegersMatrix object
        
    Raises:
        HTTPException: When matrix not found
    """
    wiegers_service = WiegersService()
    try:
        matrix = await wiegers_service.get_by_requirement_id(requirement_id)
        if not matrix:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Matriz Wiegers não encontrada para este requisito"
            )
        return matrix
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Erro ao buscar matriz Wiegers: {str(e)}"
        )
